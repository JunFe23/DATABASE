--20210222---------------------------------------------------------------
CREATE TABLE EMP1
AS
SELECT EMPNO,ENAME,SAL,COMM,JOB,MGR
FROM EMP
WHERE SAL=-1;

CREATE TABLE EMP2
AS
SELECT EMPNO,ENAME,SAL,COMM,JOB,MGR
FROM EMP
WHERE SAL=-1;

CREATE TABLE EMP3
AS
SELECT EMPNO,ENAME,SAL,COMM,JOB,MGR
FROM EMP
WHERE SAL=-1;

CREATE TABLE EMP4
AS
SELECT EMPNO,ENAME,SAL,COMM,JOB,MGR
FROM EMP
WHERE SAL=-1;

INSERT ALL
WHEN SAL BETWEEN 800 AND 1000 THEN
INTO EMP1 (EMPNO,ENAME,SAL,COMM,JOB,MGR)
VALUES(EMPNO,ENAME,SAL,COMM,JOB,MGR)

WHEN SAL BETWEEN 1001 AND 2000 THEN
INTO EMP2 (EMPNO,ENAME,SAL,COMM,JOB,MGR)
VALUES(EMPNO,ENAME,SAL,COMM,JOB,MGR)

WHEN SAL BETWEEN 2001 AND 3000 THEN
INTO EMP3 (EMPNO,ENAME,SAL,COMM,JOB,MGR)
VALUES(EMPNO,ENAME,SAL,COMM,JOB,MGR)

ELSE
INTO EMP4 (EMPNO,ENAME,SAL,COMM,JOB,MGR)
VALUES(EMPNO,ENAME,SAL,COMM,JOB,MGR)
SELECT * FROM EMP;

SELECT * FROM EMP1;
SELECT * FROM EMP2;
SELECT * FROM EMP3;
------------------------------------------------------------------------
UPDATE EMP1 SET ENAME = 'SNOOP'
WHERE SAL = (SELECT SAL FROM EMP1 WHERE ENAME = 'SMITH');
--ROLLBACK[취소] 부분완료 --> COMMIT[완전완료]
SELECT * FROM EMP2;

-- MERGE 병합
CREATE TABLE EMPMG1
AS 
SELECT EMPNO,ENAME,SAL,COMM,MGR,JOB,HIREDATE
FROM EMP
WHERE SAL BETWEEN 800 AND 2500;


CREATE TABLE EMPMG2
AS
SELECT EMPNO,ENAME,SAL,COMM,MGR,JOB,HIREDATE
FROM EMP
WHERE SAL BETWEEN 1800 AND 5000;

SELECT * FROM EMPMG1;
SELECT * FROM EMPMG2;


-- EMPNO가 같은 부분의 ENAME을 OOP로 변경.
MERGE INTO EMPMG1 E1
USING EMPMG2 E2
ON (E1.EMPNO=E2.EMPNO)
WHEN MATCHED THEN
    UPDATE SET ENAME='OOP'
    WHEN NOT MATCHED THEN
    INSERT VALUES(E2.EMPNO,E2.ENAME,E2.SAL,E2.COMM,E2.MGR,E2.JOB,E2.HIREDATE);
    
SELECT * FROM EMPMG1;
SELECT * FROM EMPMG2;

SELECT * FROM STUDENT;


CREATE TABLE STUD1
AS
SELECT STUDNO,NAME,USERID,GRADE,IDNUM,BIRTHDATE,TEL,HEIGHT,WEIGHT,DEPTNO,PROFNO
FROM STUDENT WHERE HEIGHT BETWEEN 160 AND 180;

CREATE TABLE STUD2
AS
SELECT STUDNO,NAME,USERID,GRADE,IDNUM,BIRTHDATE,TEL,HEIGHT,WEIGHT,DEPTNO,PROFNO
FROM STUDENT WHERE HEIGHT BETWEEN 170 AND 180;

MERGE INTO STUD1 S1
USING STUD2 S2
ON (S1.STUDNO=S2.STUDNO)
WHEN MATCHED THEN
    UPDATE SET NAME='SAME'
    WHEN NOT MATCHED THEN
    INSERT VALUES(S2.STUDNO,S2.NAME,S2.USERID,S2.GRADE,S2.IDNUM,S2.BIRTHDATE,S2.TEL,S2.HEIGHT,S2.WEIGHT,S2.DEPTNO,S2.PROFNO);

SELECT * FROM STUD1;

-- DML[조작어]TRANSACTION[거래], INSERT,UPDATE,DELETE,MERGE,SELECT
WITH
A AS (SELECT * FROM EMP WHERE DEPTNO IN (10,20)),
B AS (SELECT * FROM DEPT)
SELECT A.EMPNO,A.ENAME,A.SAL,A.DEPTNO,B.DNAME,B.LOC
FROM A,B
WHERE A.DEPTNO=B.DEPTNO;

-- WITH으로 표현.
WITH
S AS (SELECT * FROM STUDENT WHERE WEIGHT>=80),
P AS (SELECT * FROM PROFESSOR WHERE SAL>=300)
SELECT S.NAME SNAME,S.USERID,S.PROFNO,P.NAME PNAME,P.SAL
FROM S,P
WHERE S.PROFNO=P.PROFNO;

-- SUBQUERY로 표현.
SELECT *
FROM (SELECT EMPNO,ENAME,SAL,DEPTNO
        FROM EMP)A,(SELECT DEPTNO,DNAME,LOC FROM DEPT)B
        WHERE A.DEPTNO=B.DEPTNO;
        
-------------------------------------------------------------------------
--SEQUENCE[유일한 식별자] 기본 키 값을 자동으로 생성하기 위한 일련번호 생성 객체

CREATE SEQUENCE TABLENAME_SEQ;
DROP SEQUENCE TABLENAME_SEQ;
SELECT * FROM USER_SEQUENCES;
ALTER SEQUENCE TABLENAME_SEQ MAXVALUE 100;
SELECT TABLENAME_SEQ.NEXTVAL FROM DUAL;
SELECT TABLENAME_SEQ.CURRVAL FROM DUAL;

CREATE TABLE SEQTABLE(
NO NUMBER(5) CONSTRAINT SEQTABLE_NO_PK PRIMARY KEY,
MSG VARCHAR2(20));

-- 일련번호를 생성해주는 객체 SEQUENCE
CREATE SEQUENCE SEQTABLE_SEQ;
INSERT INTO SEQTABLE(NO,MSG) VALUES(SEQTABLE_SEQ.NEXTVAL, 'HELLO'||SEQTABLE_SEQ.NEXTVAL);
SELECT * FROM SEQTABLE;
-- PRACTICE
CREATE TABLE SEQ_PRACTICE(
NO NUMBER(5) CONSTRAINT SEQ_PRACTICE_PK PRIMARY KEY,
NAME VARCHAR2(20));
CREATE SEQUENCE SEQ_PRACTICE_SEQ;
INSERT INTO SEQ_PRACTICE(NO,NAME) VALUES(SEQ_PRACTICE_SEQ.CURRVAL, '인조인간'||SEQ_PRACTICE_SEQ.NEXTVAL);
SELECT * FROM SEQ_PRACTICE;


CREATE SEQUENCE TAB_SEQ1
INCREMENT BY 2
START WITH 2
CYCLE -- 끝나면 다시 처음부터 돌음.
MAXVALUE 50;
SELECT TAB_SEQ1.NEXTVAL FROM DUAL;

CREATE SEQUENCE TAB_SEQ2
INCREMENT BY 1
START WITH 1
CYCLE
CACHE 9
MAXVALUE 10;

DROP SEQUENCE TAB_SEQ2;

SELECT TAB_SEQ2.NEXTVAL FROM DUAL;

SELECT * FROM DICT;
SELECT * FROM DICTIONARY;
SELECT * FROM USER_TABLES; -- 사용자가 만든 테이블
SELECT * FROM ALL_TABLES; -- 전체 테이블
SELECT * FROM DBA_TABLES; -- 관리자가 만든 테이블

SELECT * FROM USER_SEQUENCES;
SELECT * FROM USER_CONSTRAINTS;
SELECT * FROM USER_VIEWS;
SELECT * FROM USER_INDEXES;

-- DEPARTMENT 동의로 DT 생성
CREATE SYNONYM DT
FOR DEPARTMENT;

SELECT * FROM DT;


-- E/R 다이어그램
-- # UNIQUE
-- #* PRIMARY KEY
-- * NOT NULL
-- O oPTION
-- 점선 -----MAY BE
-- 실선 -----MUST BE

---------------------------------------------------------------------------
-- INDEX : SELECT의 처리속도를 높이기 위해 컬럼에 부여하는 객체
SELECT * FROM USER_INDEXES;
SELECT * FROM USER_IND_COLUMNS;

SELECT * FROM STUDENT
WHERE STUDNO=10102;


SELECT * FROM EMP
WHERE SAL>= 1250 AND SAL <=3000;

SELECT ROWID,DEPTNO,DNAME,LOC FROM DEPT;

CREATE UNIQUE INDEX DEPT_DNAME_IDX
ON DEPT(DNAME ASC);

SELECT * FROM USER_INDEXES
WHERE TABLE_NAME IN('DEPT');

INSERT INTO DEPT VALUES(50,'SALES','SEOUL');

-- ORDER BY 안 하려면  INDEX 사용하면 됨.
-- INDEX 사용하면 ORDER BY 자동 적용. 

-- 실행 설명 파일 만들음.
EXPLAIN PLAN FOR
SELECT *
FROM EMP;

-- 실행 설명 파일 실행.
SELECT * FROM TABLE(dbms_XPLAN.DISPLaY);


CREATE INDEX EMP_SAL_IDX
ON EMP (SAL);

-- SAL에 INDEX값 줘서 기본적으로 정렬이 되어있다.
SELECT SAL
FROM EMP
WHERE SAL>0;

EXPLAIN PLAN FOR
SELECT * 
FROM EMP 
WHERE SAL>=2000;
SELECT *
FROM TABLE(DBMS_XPLAN.DISPLAY);

EXPLAIN PLAN FOR
SELECT * 
FROM EMP 
WHERE EMPNO=7788;
SELECT *
FROM TABLE(DBMS_XPLAN.DISPLAY);


SELECT STUDNO
FROM STUDENT
WHERE STUDNO>0;

-- Q. 몸무게가 가장 큰 사람의 학생정보 출력
SELECT *
FROM STUDENT
WHERE WEIGHT=(SELECT MAX(WEIGHT) FROM STUDENT);

-- MAKE INDEX
CREATE INDEX STUD_WEIGHT_IDX
ON STUDENT(WEIGHT DESC);
SELECT *
FROM STUDENT
WHERE WEIGHT>0 AND ROWNUM=1; -- 조건을 하나 줘야 INDEX 정렬이 적용됨.


-- Q. 연봉이 가장 많은 사람의 사원정보 출력
-- /*+*/ HINT 절 이용해서 기존 인덱스 오름차 순인 것을 변경하지 않고 내림차 순으로 검색.
SELECT /*+INDEX_DESC(EMP EMP_SAL_IDX)*/ EMPNO,ENAME,SAL,JOB,HIREDATE
FROM EMP
WHERE SAL>0 AND ROWNUM=1;


CREATE INDEX STUDENT_HEIGHT_IDX
ON STUDENT(HEIGHT);

SELECT /*+INDEX_DESC(STUDENT STUDENT_HEIGHT_IDX)*/ STUDNO,NAME,USERID,HEIGHT
FROM STUDENT
WHERE HEIGHT>0 AND ROWNUM<2;